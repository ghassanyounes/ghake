#include <iostream>       //! cout, cin, endl
#include <fstream>        //! File IO
#include <cstdlib>        //! System calls
#include <cstring>        //! strcmp
#include "functions.h"

namespace basemake
{
  STATUS macros(std::string makename,
                std::string projname, 
                compilation::COMPIL compiler, 
                std::string extension)
  {
    std::string exec = projname;
    std::string textin1; 
    std::string textin2;
    std::string objects;
    std::ofstream makefile;
    const char* makefname = makename.c_str();
    std::ifstream dependencylist;
    std::string linetext;
    

    STATUS dps = generatedeps(compiler, extension);
    if (dps == FILE_ERR || dps == FAILED)
    {
    std::cout  << "Dependency detection of source failed. Please make sure "
               << "that the current directory is writeable." << std::endl ;
    
    return FAILED; 
    }

    dependencylist.open("dependencies.txt");
    if (dependencylist.is_open() == 0)
    {
      return FILE_ERR;
    }

    textin1  = "# Makefile generated by Ghake 1.0.0 -- Ghake by Ghassan Younes";
    textin1 += "\n#\n# MACROS ======================================================================\n\n";

    textin2 = "ERASE=";
    textin2 += "rm -rf\n\n";

    for (int i = 0; i < (int)sizeof(exec); i++)
    {
      if (( exec[i] == ' '  || exec[i] == '\n' ) 
        ||( exec[i] == '\t' || exec[i] == '.'  ))
      {
        exec[i] = '_';
      }
    }

    textin2 += "EXE=";
    textin2 += exec;
    textin2 += "\n\n";

    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }

    objects = "OBJECTS=";

    while(getline(dependencylist,linetext))
    {
      std::string target(sizeof(linetext), '\0');
      for (int i = 0; linetext[i] != '.'; i++)
      {
        target[i] = linetext[i];
      }

      objects += "$(OUTDIR)";
      objects += target.c_str(); 
      objects += ".o ";
    }

    objects += "\n\n";

    makefile << textin1 << textin2 << objects << "RUNARGS=\n\n";
    dependencylist.close();
    makefile.close();
    return OK;
  }

  STATUS targets(std::string makename)
  {
    std::string targets; 
    std::ofstream makefile;
    const char* makefname = makename.c_str();

    targets = "# TARGETS ======================================================================\n\n";
    targets += "run : $(OUTDIR)$(EXE) $(OBJECTS)\n";
    targets += "\t$(MAKE) doxygen\n";
    targets += "\t$(MAKE) memchk\n";
    targets += "\t./$(OUTDIR)$(EXE) $(RUNARGS)\n\n";

    targets += "$(OUTDIR)$(EXE) : $(OBJECTS) ";
    targets += makename;
    targets += "\n";
    targets += "\t$(CC) $(OBJECTS) $(CFLAGS) $(OUTDIR)$(EXE)\n\n";

    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }
    
    makefile << targets;
    makefile.close();

    return OK;
  }

  STATUS baserules(std::string makename); ///TODO: Fill in this function
  
  STATUS dotorules(std::string makename, 
                   std::string extension)
  {
    std::ifstream dependencylist;
    std::ofstream makefile;
    std::string linetext;
    const char* makefname = makename.c_str();

    dependencylist.open("dependencies.txt");
    if (dependencylist.is_open() == 0)
    {
      return FILE_ERR;
    }

    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }

    while(getline(dependencylist,linetext))
    {
      std::string target(sizeof(linetext), '\0');
      for (int i = 0; linetext[i] != '.'; i++)
      {
        target[i] = linetext[i];
      }
      
      makefile << "$(OUTDIR)" << linetext << "\n"
               << "\t$(CC) " << target.c_str() << "." << extension 
               << " -c $(CFLAGS) $(OUTDIR)" 
               << target.c_str() << ".o \n\n";
    }
    
    dependencylist.close();
    makefile.close();

    system("rm dependencies.txt");

    return OK;
  }

  STATUS generatedeps(compilation::COMPIL compiler, std::string extension)
  {
    std::string command;
    switch (compiler)
    {
      case compilation::GCC: 
        command = "g++ -MM ";
        break;

      case compilation::GPP: 
        command = "g++ -MM ";
        break;
      
      case compilation::MICROSOFT: 
        command = "g++ -MM ";
        break;
      
      case compilation::CLANG: 
        command = "clang --user-dependencies ";
        break;

      case compilation::CLANGPP: 
        command = "clang++ --user-dependencies ";
        break;
      
      case compilation::UNIX: 
        command = "g++ -MM ";
        break;
      
      case compilation::ERR:
        return FAILED;
        break;
      
      default:
        return FAILED;
        break;
    }

    command += "*.";
    command += extension;
    command += " > dependencies.txt";

    system(command.c_str());

    return OK;

  }
}
