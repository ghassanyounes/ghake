#include <iostream>       //! cout, cin, endl
#include <fstream>        //! File IO
#include <cstdlib>        //! System calls
#include <cstring>        //! strcmp
#include "functions.h"


namespace basemake
{
  /**
   * 
   * @brief
   *  This function generates the macros in the makefile
   * 
   * @param makename
   *  The name of the makefile to write to
   * 
   * @param projname
   *  Name of the current project
   * 
   * @param compiler
   *  Compiler to be used
   * 
   * @param extension
   *  File extension of source code files
   * 
   * @param debugger
   *  Memory debugger to be used
   * 
   * @param debugargs
   *  Memory debugger CLI arguments
   * 
   * @return
   *  Returns the status of the write operations
   * 
   */
  STATUS macros(const std::string makename,
                const std::string projname, 
                const compilation::COMPIL compiler, 
                const std::string extension,
                const memorydebug::MMCHK debugger,
                const std::string debugargs)
  {
    std::string exec = projname;                //! Executable
    std::string textin1;                        //! First set of text to write
    std::string textin2;                        //! Second set of text
    std::string dbg;                            //! Wich debugger?
    std::string objects;
    std::ofstream makefile;
    const char* makefname = makename.c_str();
    std::ifstream dependencylist;
    std::string linetext;
    

    STATUS dps = generatedeps(compiler, extension);
    if (dps == FILE_ERR || dps == FAILED)
    {
    std::cout  << "Dependency detection of source failed. Please make sure "
               << "that the current directory is writeable." << std::endl ;
    
    return FAILED; 
    }

    dependencylist.open("dependencies.txt");
    if (dependencylist.is_open() == 0)
    {
      return FILE_ERR;
    }

    textin1  = "# Makefile generated by Ghake 1.0.0 -- Ghake by Ghassan Younes";
    textin1 += "\n#\n# MACROS ======================================================================\n\n";

    textin2 = "ERASE=";
    textin2 += "rm -rf\n\n";

    for (int i = 0; i < (int)sizeof(exec); i++)
    {
      if (( exec[i] == ' '  || exec[i] == '\n' ) 
        ||( exec[i] == '\t' || exec[i] == '.'  ))
      {
        exec[i] = '_';
      }
    }

    textin2 += "EXE=";
    textin2 += exec;
    textin2 += "\n\n";

    switch (debugger)
    {
    case memorydebug::VALG:
      dbg = "valgrind";
      break;
    
    case memorydebug::DRMEM:
      dbg = "drmemory";
      break;

    case memorydebug::ERR:
      dbg = " ";
      break;

    default:
      dbg = " ";
      break;
    }

    textin2 += "MDEBUG=";
    textin2 += dbg;
    textin2 += "\n\n";
    
    textin2 += "MDARGS=";
    textin2 += debugargs;
    textin2 += "\n\n";

    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }

    objects = "OBJECTS=";

    while(getline(dependencylist,linetext))
    {
      std::string target(sizeof(linetext), '\0');
      for (int i = 0; linetext[i] != '.'; i++)
      {
        target[i] = linetext[i];
      }

      objects += "$(OUTDIR)";
      objects += target.c_str(); 
      objects += ".o ";
    }

    objects += "\n\n";

    makefile << textin1 << textin2 << objects << "RUNARGS=\n\n";
    dependencylist.close();
    makefile.close();
    return OK;
  }

  /**
   * 
   * @brief
   *  Injects the generic targets into the makefile (executable and run command)
   * 
   * @param makename
   *  Name of the makefile to inject into
   * 
   * @return
   *  Returns the status of the function
   * 
   */
  STATUS targets(std::string makename)
  {
    std::string targets; 
    std::ofstream makefile;
    const char* makefname = makename.c_str();

    targets = "# TARGETS ======================================================================\n\n";
    targets += "run : $(OUTDIR)$(EXE) $(OBJECTS)\n";
    targets += "\t$(MAKE) doxygen\n";
    targets += "\t$(MAKE) memchk\n";
    targets += "\t./$(OUTDIR)$(EXE) $(RUNARGS)\n\n";

    targets += "$(OUTDIR)$(EXE) : $(OBJECTS) ";
    targets += makename;
    targets += "\n";
    targets += "\t$(CC) $(OBJECTS) $(CFLAGS) $(OUTDIR)$(EXE)\n\n";

    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }
    
    makefile << targets;
    makefile.close();

    return OK;
  }


  /**
   * 
   * @brief
   *  Injects the base targets into the makefile (clean, rebuild)
   * 
   * @param makename
   *  Name of the makefile to inject into
   * 
   * @return
   *  Returns the status of the function
   * 
   */
  STATUS baserules(std::string makename)
  {
    std::string target;
    std::ofstream makefile;
    const char* makefname = makename.c_str();

    target  = "clean : \n";
    target += "\t@$(ERASE) $(OUTDIR)*\n\n";

    target += "rebuild :\n";
    target += "\t$(MAKE) clean\n";
    target += "\t$(MAKE)\n\n";

    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }

    makefile << target;
    makefile.close();

    return OK;
  }
  
  /**
   * 
   * @brief
   *  Injects the object file targets into the makefile
   * 
   * @param makename
   *  Name of the makefile to inject into
   * 
   * @param extension
   *  File extension of source files
   * 
   * @return
   *  Returns the status of the function
   * 
   */
  STATUS dotorules(std::string makename, 
                   std::string extension)
  {
    std::ifstream dependencylist;
    std::ofstream makefile;
    std::string linetext;
    const char* makefname = makename.c_str();

    dependencylist.open("dependencies.txt");
    if (dependencylist.is_open() == 0)
    {
      return FILE_ERR;
    }

    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }

    while(getline(dependencylist,linetext))
    {
      std::string target(sizeof(linetext), '\0');
      for (int i = 0; linetext[i] != '.'; i++)
      {
        target[i] = linetext[i];
      }
      
      makefile << "$(OUTDIR)" << linetext << "\n"
               << "\t$(CC) " << target.c_str() << "." << extension 
               << " -c $(CFLAGS) $(OUTDIR)" 
               << target.c_str() << ".o \n\n";
    }
    
    dependencylist.close();
    makefile.close();

    system("rm dependencies.txt");

    return OK;
  }

  /**
   * 
   * @brief
   *  Injects the object file targets into the makefile
   * 
   * @param compiler
   *  Compiler being requested by the user
   * 
   * @param extension
   *  File extension of source files
   * 
   * @return
   *  Returns the status of the function
   * 
   */
  STATUS generatedeps(compilation::COMPIL compiler, std::string extension)
  {
    std::string command;
    switch (compiler)
    {
      case compilation::GCC: 
        command = "g++ -MM ";
        break;

      case compilation::GPP: 
        command = "g++ -MM ";
        break;
      
      case compilation::MICROSOFT: 
        command = "g++ -MM ";
        break;
      
      case compilation::CLANG: 
        command = "clang --user-dependencies ";
        break;

      case compilation::CLANGPP: 
        command = "clang++ --user-dependencies ";
        break;
      
      case compilation::UNIX: 
        command = "g++ -MM ";
        break;
      
      case compilation::ERR:
        return FAILED;
        break;
      
      default:
        return FAILED;
        break;
    }

    command += "*.";
    command += extension;
    command += " > dependencies.txt";

    system(command.c_str());

    return OK;

  }
}
