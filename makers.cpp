#include <iostream>       //! cout, cin, endl
#include <fstream>        //! File IO
#include <cstdlib>        //! System calls
#include <cstring>        //! strcmp
#include "functions.h"

namespace basemake
{
  STATUS macros(std::string makename, std::string driver)
  {
    std::string textin1; 
    textin1  = "# Makefile generated by Ghake 1.0.0 -- Ghake by Ghassan Younes";
    textin1 += "\n#\n# MACROS ======================================================================\n\n";
    std::string textin2 = "DRIVER=";
    textin2 += driver;
    textin2 += "\n";
    std::ofstream makefile;
    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    const char* makefname = makename.c_str();
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }
    
    makefile << textin1 << textin2 << "\n";
    makefile.close();
    return OK;
  }
  STATUS targets(std::string makename)
  {
    std::string targets; 
    targets = "# TARGETS ======================================================================\n\n";
    targets += "run : $(OUTDIR)$(EXE) $(OBJECTS)\n";
    targets += "\t$(MAKE) doxygen\n";
    targets += "\t$(MAKE) memchk\n";
    targets += "\t./$(OUTDIR)$(EXE) $(RUNARGS)\n\n";

    targets += "$(OUTDIR)$(EXE) : $(OBJECTS) makefile\n";
    targets += "\t$(CC) $(OBJECTS) $(CFLAGS) $(OUTDIR)$(EXE)\n";

    targets += "$(OUTDIR)$(DRIVER).o : $(DRIVER).cpp functions.h";
	  targets += "\t$(CC) $(DRIVER).cpp -c $(CFLAGS) $(OUTDIR)$(DRIVER).o";

    std::ofstream makefile;
    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    const char* makefname = makename.c_str();
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }
    
    makefile << targets << "\n";
    makefile.close();

    return OK;
  }
  STATUS baserules(std::string makename); ///TODO: Fill in this function
  STATUS dotorules(std::string makename, 
                   compilation::COMPIL compiler, 
                   std::string extension)
  {
    std::string command;
    switch (compiler)
    {
      case compilation::GCC: 
        command = "g++ -MM ";
        break;

      case compilation::GPP: 
        command = "g++ -MM ";
        break;
      
      case compilation::MICROSOFT: 
        command = "g++ -MM ";
        break;
      
      case compilation::CLANG: 
        command = "g++ -MM ";
        break;
      
      case compilation::UNIX: 
        command = "g++ -MM ";
        break;
      
      case compilation::ERR:
        return FAILED;
        break;
      
      default:
        return FAILED;
        break;
    }

    command += "*.";
    command += extension;
    command += " > dependencies.txt";

    system(command.c_str());
    std::ifstream dependencylist;
    dependencylist.open("dependencies.txt");
    std::string linetext;
    if (dependencylist.is_open() == 0)
    {
      return FILE_ERR;
    }
    std::ofstream makefile;
    // std::ios::app is the open mode "append" meaning
    // new data will be written to the end of the file.
    const char* makefname = makename.c_str();
    makefile.open(makefname, std::ios::app);
    if (makefile.is_open() == 0)
    {
      return FILE_ERR;
    }

    while(getline(dependencylist,linetext))
    {
      std::string target(sizeof(linetext), '\0');
      for (int i = 0; linetext[i] != '.'; i++)
      {
        target[i] = linetext[i];
      }
      
      makefile << "$(OUTDIR)" << linetext << "\n"
               << "\t$(CC) " << target.c_str() << "." << extension 
               << " -c $(CFLAGS) $(OUTDIR)" 
               << target.c_str() << ".o \n\n";
    }
    
    //makefile << targets << "\n";
    dependencylist.close();
    makefile.close();

    system("rm dependencies.txt");

    return OK;
  }
}
